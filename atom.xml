<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>烏鴉囈語</title>
  
  <subtitle>無病呻吟之地</subtitle>
  <link href="http://withoutdirection.github.io/atom.xml" rel="self"/>
  
  <link href="http://withoutdirection.github.io/"/>
  <updated>2025-02-13T12:47:06.587Z</updated>
  <id>http://withoutdirection.github.io/</id>
  
  <author>
    <name>烏鴉先生</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Test post</title>
    <link href="http://withoutdirection.github.io/2025/02/13/test/"/>
    <id>http://withoutdirection.github.io/2025/02/13/test/</id>
    <published>2025-02-13T11:58:02.474Z</published>
    <updated>2025-02-13T12:47:06.587Z</updated>
    
    <content type="html"><![CDATA[<h1 id="EEG-Undergraduat-Research"><a href="#EEG-Undergraduat-Research" class="headerlink" title="EEG_Undergraduat_Research"></a>EEG_Undergraduat_Research</h1><p>專題_EEG</p><hr><h2 id="0321-Stage-1"><a href="#0321-Stage-1" class="headerlink" title="0321: Stage 1"></a>0321: Stage 1</h2><h3 id="Outline"><a href="#Outline" class="headerlink" title="Outline"></a>Outline</h3><p>透過pylsl抓取EEG訊號在preprocess過後透過unsupervised learning algorithm自動判別 alpha power在睜眼與閉眼之間的threshold</p><h3 id="Dataset"><a href="#Dataset" class="headerlink" title="Dataset"></a>Dataset</h3><p>Subject: 2<br>EEG recording length: 30s, 0~10: Eyes closed; 10~20: Eyes opened; 20~30: Eyes closed</p><h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h3><p>Data preprocess: ???<br>To consider time-domain features, unsupervised: ???</p><h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><hr><h2 id="0328-Preprocess"><a href="#0328-Preprocess" class="headerlink" title="0328: Preprocess"></a>0328: Preprocess</h2><p><a href="https://github.com/cemeteryparty/real_time_LSL_BCI.git">LAB resource</a></p><h3 id="load-data"><a href="#load-data" class="headerlink" title="load data"></a>load data</h3><p>“””</p><pre><code>print(&quot;looking for an EEG stream...&quot;)streamList = pylsl.resolve_streams()streamList = [StreamInfo_(s) for s in streamList]tb = pt.PrettyTable()tb.field_names = [&quot;sid&quot;, &quot;name&quot;, &quot;type&quot;, &quot;#_channel&quot;, &quot;srate&quot;, &quot;srcID&quot;]for sid, stm in enumerate(streamList):    sinfo = [sid, stm.name, stm.type, stm.n_chan, stm.srate, stm.ssid]    tb.add_row(sinfo)    # print(stm)print(tb)streamID = int(input(&quot;Select steam... &quot;))selcStream = streamList[streamID]</code></pre><p>“””</p><ol><li>利用lsl讀取EEG裝置(Cyguns)透過udp 傳出之訊號</li><li>解析並透過prettytable 將裝置與 EEG資訊以表格形式呈現，類似:<table><thead><tr><th align="center">sid</th><th align="center">name</th><th align="center">type</th><th align="center">#_channel</th><th align="center">srate</th><th align="center">srcID</th></tr></thead><tbody><tr><td align="center">拿來幫助選要用</td><td align="center">裝置實體名稱</td><td align="center">訊號類型</td><td align="center">頻道數量</td><td align="center">取樣率</td><td align="center"><strong>我不知道</strong></td></tr><tr><td align="center">哪個裝置當data src</td><td align="center">E.g. Cygnus-xxx</td><td align="center">E.g. EEG</td><td align="center">E.g. 32</td><td align="center">E.g. 1000.0</td><td align="center">???</td></tr></tbody></table></li><li>選裝置做為要拿去進入整個model的data source</li></ol><h3 id="construct-object-for-data"><a href="#construct-object-for-data" class="headerlink" title="construct object for data"></a>construct object for data</h3><p><code>root = BasicRecv(stm.n_chan, selcStream.srate)</code></p><pre><code>*Basic Recdiver 為 SigIntercept之子類別*</code></pre><ul><li><p>Bacic Recdiver<br>-&gt; input:   number of channels &#x3D; n_channel&#x2F; sampling rate &#x3D; sfreq<br>-&gt; 利用 input 與 buffer_size透過 <strong>SigIntercept</strong> 初始化Receiver<br>-&gt; buffer_size 為提供則設定為 sampling rate 之30倍 <del>主程式run.py裡根本沒有讓人發現這個input的可能lol</del>  </p></li><li><p>SigIntercept(這個好重要我看好久)</p></li></ul><ol><li><p>內容物(屬性)</p><ul><li>buffer: 拿來存資料的 <em>shape &#x3D; (n_chan * n_timestamps)</em></li><li>time stamps: 紀錄時間資訊 <em>shape &#x3D; (1 * n_timestamps)</em></li><li>flag: 拿來標記特定時間是啥的 <em>shape &#x3D; (? * n_timestamps)</em></li><li>sampling rate: 取樣率</li><li>raiseStream: 拿來將處理好&#x2F; 未處裡的資料送出去的 … 嗎?</li><li>parent: <del>???</del></li><li>nextFID: 下一位來賓是誰</li></ul></li><li><p>function(方法)</p><ul><li>update:<ol><li><p>先抓x(input) 有多長</p></li><li><p>將原本buffer整筆資料往左推直到後面有x_len的空間<br> “””</p><pre><code> xLen = x.shape[1] self.buffer[:, :self.bufShape[1] - xLen] = self.buffer[:, xLen:] self.buffer[:, -xLen:] = x</code></pre><p> “””</p></li><li><p>更新buffer新的資料時間並打上flag: nextFID， 原本往左推的tstmps&#x2F; flags也往左推</p></li><li><p>更新nextFID</p><p> “””</p><pre><code> self.tstmps += (x.shape[1] / self.sfreq) self.flags[:self.bufShape[1] - xLen] = self.flags[xLen:] self.flags[-xLen:] = self.nextFID self.nextFID += 1</code></pre><p> “””</p></li></ol></li><li>step: 交由<em>parent</em>更新</li><li>send: 發送訊號 <del>沒看很懂</del></li></ul></li></ol><h3 id="preprocess"><a href="#preprocess" class="headerlink" title="preprocess"></a>preprocess</h3><p><code>block1 = PreProcessing(2, 40, selcStream.srate, 128.0, parent=root) # 1, 40</code></p><pre><code>-&gt; Preprocessing(目標最低頻, 目標最高頻, 輸入取樣率, 輸出取樣率, parent)</code></pre><ul><li>PreProcessing<br>-&gt; 透過<strong>SigIntercept</strong> 建立處裡完的訊號物件<br>-&gt; 透過自定義的filter 濾掉訊號 <del>我看不懂filter</del><br>-&gt; 透過step更新buffer並分段處理input</li></ul><p>~~待續</p><hr><h2 id="0404-Preprocess"><a href="#0404-Preprocess" class="headerlink" title="0404: Preprocess"></a>0404: Preprocess</h2><h3 id="preprocess-in-custom-py"><a href="#preprocess-in-custom-py" class="headerlink" title="preprocess(in custom.py)"></a>preprocess(in custom.py)</h3><ol><li><p>initialize the object<br> 父類別為 <strong>SigIntercept</strong> </p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, l_freq, h_freq, sfreq_IS, sfreq_OS, parent</span>):</span><br><span class="line">    duration = <span class="number">30.0</span></span><br><span class="line">    n_chan = parent.bufShape[<span class="number">0</span>]</span><br><span class="line">    <span class="built_in">super</span>(PreProcessing, <span class="variable language_">self</span>).__init__(</span><br><span class="line">        (n_chan, math.ceil(duration * sfreq_OS)),</span><br><span class="line">        raiseStream=<span class="literal">False</span>, name=<span class="string">&quot;hidden_1&quot;</span>, sfreq=sfreq_OS, parent=parent</span><br><span class="line">    )</span><br><span class="line">    <span class="variable language_">self</span>.sfreq_IS, <span class="variable language_">self</span>.sfreq_OS = sfreq_IS, sfreq_OS</span><br><span class="line">    <span class="variable language_">self</span>.filt = _create_filter(l_freq, h_freq, fs=<span class="variable language_">self</span>.sfreq_IS)</span><br><span class="line">    <span class="comment">#self.b_notch, self.a_notch = signal.iirnotch(w0=50.0, Q=20.0, fs=fsIn)  #Lab60, BCIERN50</span></span><br><span class="line">    <span class="variable language_">self</span>.x_part = np.zeros((<span class="variable language_">self</span>.bufShape[<span class="number">0</span>], <span class="number">0</span>), dtype=np.float32)</span><br></pre></td></tr></table></figure><ul><li><p>the concept of filter(濾波器)<br><strong>Finite Impulse Response</strong><br>[前情提要: DSP是啥- 未完成]<br>Finite: 濾波器對於訊號的反應時間是有限的，代表脈衝響應(Impluse response)有明確的開始和結束<br>Impluse: 持續時間極短但具有有限能量的信號。<br>Response: 濾波器的響應指的是當它受到輸入信號時的輸出。對於FIR濾波器來說，響應是通過將輸入信號與濾波器的有限脈衝響應進行卷積來確定的。這個卷積運算描述了濾波器如何修改輸入信號以產生所需的輸出信號。<br><img src="/2025/02/13/test/fir_def.png" alt="FIR def"><br><img src="/2025/02/13/test/fir_funct.png" alt="FIR funct"><br>訊號在FIT濾波器下變化的模式 -&gt;<br>假設有一訊號，為如下圖形：<br><img src="/2025/02/13/test/image.png" alt="signal"><br>傅立葉轉換後圖型如下，在此希望將其高頻部份濾除，只保留低頻部份：(黑細線為原本訊號的傅立葉轉換，紅粗線為希望保留與濾除的頻率分界)<br><img src="/2025/02/13/test/image-2.png" alt="after FFT"><br>因此，在傅立葉空間定義出上述紅線的函數，並將此函數與原本訊號的傅立葉轉換相乘：<br><img src="/2025/02/13/test/image-1.png" alt="after filter"><br>再做傅立葉逆轉換，就可得到濾除高頻部份的圖型 ：<br><img src="/2025/02/13/test/image-3.png" alt="Inverse-FFT"></p></li><li><p>code implement</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_create_filter</span>(<span class="params">l_freq, h_freq, fs, l_trans_bw=<span class="number">1</span>, h_trans_bw=<span class="number">1</span>, window=<span class="string">&quot;hamming&quot;</span>, phase=<span class="string">&quot;causal&quot;</span></span>):</span><br><span class="line"><span class="comment"># https://github.com/mne-tools/mne-python/blob/maint/1.5/mne/filter.py#L1126</span></span><br><span class="line"><span class="comment"># https://github.com/mne-tools/mne-python/blob/maint/1.5/mne/filter.py#L473</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; filter_order &quot;&quot;&quot;</span></span><br><span class="line">N = _length_factors[<span class="string">&quot;hamming&quot;</span>] / (<span class="number">1</span> / fs)</span><br><span class="line">N = math.ceil(N / <span class="number">2</span>) * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> phase == <span class="string">&quot;causal&quot;</span>:</span><br><span class="line">    N = N * <span class="number">2</span> - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; construct transition gain &quot;&quot;&quot;</span></span><br><span class="line">freq = [l_freq - l_trans_bw, l_freq, h_freq, h_freq + h_trans_bw]</span><br><span class="line">gain = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line"><span class="keyword">if</span> freq[-<span class="number">1</span>] != fs / <span class="number">2.0</span>:</span><br><span class="line">    freq += [fs / <span class="number">2.0</span>]</span><br><span class="line">    gain += [<span class="number">0</span>]</span><br><span class="line"><span class="keyword">if</span> freq[<span class="number">0</span>] != <span class="number">0</span>:</span><br><span class="line">    freq = [<span class="number">0</span>] + freq</span><br><span class="line">    gain = [<span class="number">0</span>] + gain</span><br><span class="line">freq = np.array(freq) / (fs / <span class="number">2.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; construct filter response &quot;&quot;&quot;</span></span><br><span class="line">h = np.zeros(N, dtype=np.float32)</span><br><span class="line">prev_freq, prev_gain = freq[-<span class="number">1</span>], gain[-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> this_freq, this_gain <span class="keyword">in</span> <span class="built_in">zip</span>(freq[::-<span class="number">1</span>][<span class="number">1</span>:], gain[::-<span class="number">1</span>][<span class="number">1</span>:]):</span><br><span class="line">    <span class="keyword">if</span> this_gain != prev_gain:</span><br><span class="line">        transition = (prev_freq - this_freq) / <span class="number">2.0</span></span><br><span class="line">        this_N = <span class="built_in">int</span>(<span class="built_in">round</span>(_length_factors[window] / transition))</span><br><span class="line">        this_N += <span class="number">1</span> - this_N % <span class="number">2</span>  <span class="comment"># make it odd</span></span><br><span class="line"></span><br><span class="line">        this_h = firwin(</span><br><span class="line">            this_N,</span><br><span class="line">            (prev_freq + this_freq) / <span class="number">2.0</span>,</span><br><span class="line">            window=window,</span><br><span class="line">            pass_zero=<span class="literal">True</span>,</span><br><span class="line">            fs=freq[-<span class="number">1</span>] * <span class="number">2</span>,</span><br><span class="line">        )</span><br><span class="line">        offset = (N - this_N) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> this_gain == <span class="number">0</span>:</span><br><span class="line">            h[offset : N - offset] -= this_h</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            h[offset : N - offset] += this_h</span><br><span class="line">    prev_gain = this_gain</span><br><span class="line">    prev_freq = this_freq</span><br><span class="line"><span class="keyword">if</span> phase == <span class="string">&quot;causal&quot;</span>:</span><br><span class="line">    h = minimum_phase(h)</span><br><span class="line"><span class="keyword">return</span> h</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>輸入參數: (低通頻率（l_freq）、高通頻率（h_freq）、採樣率（fs）、過渡帶寬度（l_trans_bw和h_trans_bw）、窗口類型（window）、相位類型（phase）)</li><li>決定濾波器長度(根據window 類型與 取樣率) </li><li>transition gain(過度增益):<del>這邊好難</del> 用來確保在低通濾波器和高通濾波器之間平滑過渡，使頻率響應在過渡區域內盡可能平滑，從而減少濾波器的振蕩或不穩定行為。</li><li>建構濾波器響應: 對 freq 和 gain 進行反向迭代，對於每一對頻率和增益，如果它們的增益不同，則計算兩者之間的過渡帶寬度，並根據這個過渡帶寬度來計算一個對應的濾波器響應。最終，將這些部分濾波器響應組合起來，得到最終的濾波器響應。 (如果phase是casule則將通過最小相位函數（minimum_phase）來確保濾波器是causal的。)</li></ol><p><code>一個因果濾波器是指濾波器的輸出僅依賴於當前和過去的輸入值，而不依賴未來的輸入值。換句話說，濾波器的輸出只取決於當前時間及之前的輸入，不受未來輸入的影響。</code></p></li></ul></li><li><p>process the signal by step</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">step</span>(<span class="params">self</span>):</span><br><span class="line">     filt = <span class="variable language_">self</span>.filt</span><br><span class="line">     buffer = <span class="variable language_">self</span>.parent.buffer</span><br><span class="line">     n_chan = buffer.shape[<span class="number">0</span>]</span><br><span class="line">     offset_beg = np.searchsorted(<span class="variable language_">self</span>.parent.flags, <span class="variable language_">self</span>.nextFID, side=<span class="string">&quot;left&quot;</span>)</span><br><span class="line">     xLen = buffer.shape[<span class="number">1</span>] - offset_beg</span><br><span class="line"></span><br><span class="line">     <span class="variable language_">self</span>.x_part = np.append(<span class="variable language_">self</span>.x_part, buffer[:, -xLen:], axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">     <span class="string">&quot;&quot;&quot; band pass filtering &quot;&quot;&quot;</span></span><br><span class="line">     xf_part = np.zeros(</span><br><span class="line">         (n_chan, <span class="variable language_">self</span>.x_part.shape[<span class="number">1</span>] - <span class="built_in">len</span>(filt) + <span class="number">1</span>), dtype=np.float32)</span><br><span class="line">     <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(n_chan):</span><br><span class="line">         xf_part[c] = oaconvolve(<span class="variable language_">self</span>.x_part[c], filt, mode=<span class="string">&quot;valid&quot;</span>)</span><br><span class="line">     <span class="comment"># zero-padding: edge effect, leave out of valid to next iteration</span></span><br><span class="line">     <span class="variable language_">self</span>.x_part = <span class="variable language_">self</span>.x_part[:, -(<span class="built_in">len</span>(filt) - <span class="number">1</span>):]</span><br><span class="line"></span><br><span class="line">     <span class="string">&quot;&quot;&quot; average rereference &quot;&quot;&quot;</span></span><br><span class="line">     <span class="comment">##xf_part -= xf_part.mean(axis=0)</span></span><br><span class="line"></span><br><span class="line">     <span class="string">&quot;&quot;&quot; resample &quot;&quot;&quot;</span></span><br><span class="line">     t_bef = np.linspace(<span class="number">0</span>, xf_part.shape[<span class="number">1</span>] / <span class="variable language_">self</span>.sfreq_IS, xf_part.shape[<span class="number">1</span>], endpoint=<span class="literal">False</span>)</span><br><span class="line">     t_aft = np.linspace(</span><br><span class="line">         <span class="number">0</span>, xf_part.shape[<span class="number">1</span>] / <span class="variable language_">self</span>.sfreq_IS,</span><br><span class="line">         <span class="built_in">int</span>(xf_part.shape[<span class="number">1</span>] / <span class="variable language_">self</span>.sfreq_IS * <span class="variable language_">self</span>.sfreq_OS), endpoint=<span class="literal">False</span></span><br><span class="line">     )</span><br><span class="line">     x_new = np.zeros((n_chan, t_aft.size))</span><br><span class="line">     <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(n_chan):</span><br><span class="line">         x_new[c] = np.interp(t_aft, t_bef, xf_part[c])</span><br><span class="line">     <span class="keyword">return</span> x_new</span><br></pre></td></tr></table></figure><ul><li><p>parameter’s meaning:</p><ol><li>offset_beg &#x3D; np.searchsorted(self.parent.flags, self.nextFID, side&#x3D;”left”): 下一個要處理的數據的起始索引。np.searchsorted 函數在 self.parent.flags 中查找 self.nextFID，並返回插入 self.nextFID 而不破壞排序的索引位置。side&#x3D;”left” 表示在相等元素的左邊插入。</li><li>xLen: offset_beg 到 buffer 結束的數據長度，即還未處理的數據的長度。</li></ol></li><li><p>濾波：首先，將新的數據添加到x_part。然後，對每個通道的數據進行卷積操作，使用在 初始化時建立的濾波器FIR進行帶通濾波。<strong>最後，保留一部分數據以處理邊緣效應。</strong></p></li><li><p><del>降噪</del>(被註解掉了): 將每個通道的數據中減去平均值</p></li><li><p>Resample: 過插值實現將其從原始採樣率 self.sfreq_IS 轉換為輸出採樣率 self.sfreq_OS。</p></li></ul></li></ol><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;EEG-Undergraduat-Research&quot;&gt;&lt;a href=&quot;#EEG-Undergraduat-Research&quot; class=&quot;headerlink&quot; title=&quot;EEG_Undergraduat_Research&quot;&gt;&lt;/a&gt;EEG_Undergr</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://withoutdirection.github.io/2025/02/13/hello-world/"/>
    <id>http://withoutdirection.github.io/2025/02/13/hello-world/</id>
    <published>2025-02-13T09:48:17.579Z</published>
    <updated>2025-02-13T09:48:17.579Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
